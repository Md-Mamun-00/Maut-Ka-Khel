<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Angry Hero - 90s Action</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bungee+Spice&family=Teko:wght@400;700&display=swap');
        
        body {
            background-color: #1a0f0a;
            overflow: hidden;
            touch-action: none;
            font-family: 'Teko', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            filter: contrast(1.1) saturate(1.2);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        .title {
            font-size: clamp(3rem, 10vw, 6rem);
            font-family: 'Bungee Spice', cursive;
            text-transform: uppercase;
            margin-bottom: 0;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .subtitle {
            font-size: 1.5rem;
            color: #ffd700;
            text-shadow: 2px 2px #000;
            margin-bottom: 40px;
            opacity: 0;
            transition: opacity 0.5s ease 0.4s;
        }

        .btn {
            pointer-events: auto;
            background: #e63946;
            border: 4px solid #fff;
            color: #fff;
            padding: 10px 40px;
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 6px 6px 0px #000;
            opacity: 0;
            transition: all 0.3s;
        }

        .visible {
            opacity: 1 !important;
            transform: scale(1) !important;
        }

        #score-hud {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 2.5rem;
            color: #fff;
            text-shadow: 3px 3px #e63946;
            pointer-events: none;
            display: none;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.05) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>

    <div id="ui-layer">
        <h1 class="title visible" id="main-title">MAUT KA KHEL</h1>
        <p class="subtitle visible" id="sub-title">90'S ACTION BLOCKBUSTER</p>
        <button class="btn visible" id="start-btn">PLAY GAME</button>
        <button class="btn" style="display:none" id="restart-btn">RETRY</button>
    </div>

    <div id="score-hud">SCORE: 0</div>

<script>
/**
 * AUDIO & ASSET SYSTEM
 */
const charImg = new Image();
charImg.src = '20251226_201057.png';

class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.gameOverSound = new Audio('soundeffect.ogg');
    }

    playFlip() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }

    playGameOver() {
        this.gameOverSound.play().catch(e => console.log("Audio Error:", e));
    }
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const sound = new SoundManager();

let gameState = 'MENU';
let frames = 0, score = 0, speed = 7;
let floorY, ceilingY;
let player, obstacles = [], particles = [];

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    floorY = canvas.height - 100;
    ceilingY = 100;
}
window.addEventListener('resize', resize);
resize();

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.life = 1;
        this.color = color;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= 0.02; }
    draw() {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 3, 3);
        ctx.globalAlpha = 1;
    }
}

class Hero {
    constructor() {
        this.size = 80; // Scaled down from 1000 to fit screen but high res source
        this.x = 100;
        this.y = floorY - this.size;
        this.isUp = false;
        this.targetY = this.y;
        this.rotation = 0;
    }
    flip() {
        this.isUp = !this.isUp;
        this.targetY = this.isUp ? ceilingY : floorY - this.size;
        sound.playFlip();
    }
    update() {
        const oldY = this.y;
        this.y += (this.targetY - this.y) * 0.18;
        
        // Rotate based on movement direction
        const dy = this.y - oldY;
        this.rotation = dy * 0.05; // Tilts as it shifts path
    }
    draw() {
        ctx.save();
        ctx.translate(this.x + this.size/2, this.y + this.size/2);
        ctx.rotate(this.rotation);
        
        // Drawing character
        if (charImg.complete) {
            ctx.drawImage(charImg, -this.size/2, -this.size/2, this.size, this.size);
        } else {
            // Fallback placeholder
            ctx.fillStyle = '#e63946';
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        }
        ctx.restore();
    }
}

class FireObstacle {
    constructor() {
        this.w = 50;
        this.h = Math.random() * 100 + 80;
        this.x = canvas.width + 100;
        this.onCeiling = Math.random() > 0.5;
        this.y = this.onCeiling ? ceilingY : floorY - this.h;
    }
    update() {
        this.x -= speed;
        if (Math.random() > 0.5) {
            particles.push(new Particle(this.x + Math.random()*this.w, this.y + (this.onCeiling?this.h:0), '#ff4500'));
        }
    }
    draw() {
        let grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
        grad.addColorStop(this.onCeiling ? 1 : 0, '#ff0000');
        grad.addColorStop(0.5, '#ffd700');
        grad.addColorStop(this.onCeiling ? 0 : 1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(this.x, this.y, this.w, this.h);
    }
}

function init() {
    player = new Hero();
    obstacles = [];
    particles = [];
    score = 0;
    speed = 8;
    frames = 0;
    document.getElementById('score-hud').innerText = "SCORE: 0";
}

function loop() {
    if (gameState !== 'PLAYING') return;

    // Background
    ctx.fillStyle = '#1e140f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Road/Path lines
    ctx.strokeStyle = '#2d2119';
    ctx.lineWidth = 2;
    for(let i=0; i<canvas.width; i+=100) {
        ctx.beginPath();
        ctx.moveTo(i - (frames*speed)%100, floorY);
        ctx.lineTo(i - (frames*speed)%100, ceilingY);
        ctx.stroke();
    }

    player.update();
    player.draw();

    if (frames % 70 === 0) {
        obstacles.push(new FireObstacle());
        speed += 0.08;
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let obs = obstacles[i];
        obs.update();
        obs.draw();

        // Collision
        if (player.x + 10 < obs.x + obs.w && player.x + player.size - 10 > obs.x &&
            player.y + 10 < obs.y + obs.h && player.y + player.size - 10 > obs.y) {
            gameOver();
        }

        if (!obs.passed && player.x > obs.x + obs.w) {
            obs.passed = true;
            score += 100;
            document.getElementById('score-hud').innerText = "SCORE: " + score;
        }

        if (obs.x + obs.w < -100) obstacles.splice(i, 1);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw();
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    frames++;
    requestAnimationFrame(loop);
}

function triggerAction() {
    if (gameState === 'MENU') startGame();
    else if (gameState === 'PLAYING') player.flip();
    else if (gameState === 'GAMEOVER') location.reload();
}

window.addEventListener('mousedown', triggerAction);
window.addEventListener('touchstart', (e) => { e.preventDefault(); triggerAction(); }, {passive: false});
window.addEventListener('keydown', (e) => { if(e.code === 'Space') triggerAction(); });

function startGame() {
    gameState = 'PLAYING';
    document.getElementById('main-title').classList.remove('visible');
    document.getElementById('sub-title').classList.remove('visible');
    document.getElementById('start-btn').classList.remove('visible');
    document.getElementById('score-hud').style.display = 'block';
    init();
    loop();
}

function gameOver() {
    gameState = 'GAMEOVER';
    sound.playGameOver();
    
    document.getElementById('main-title').innerText = "GAME OVER";
    document.getElementById('main-title').style.color = "#ff0000";
    document.getElementById('main-title').classList.add('visible');
    
    const rb = document.getElementById('restart-btn');
    rb.style.display = 'block';
    setTimeout(() => rb.classList.add('visible'), 50);
}

resize();
ctx.fillStyle = '#1a0f0a';
ctx.fillRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>

